### **核心模型**

1. **三棵树概念**
   - **current 树**：最新渲染的 Fiber 树（指向真实 DOM 状态）
   - **workInProgress 树**：正在构建的新 Fiber 树（挂载更新）
   - **历史树**（可选）：更早的旧树，已经不再 current，也不是当前 workInProgress，但在内存中存在（等待 GC 或被复用）： **Fiber 节点复用、状态保留和中间更新回退**
2. **双缓冲机制**
   - React 只对 **current ↔ workInProgress** 建立 alternate 链（双缓冲）
   - 历史树不参与直接更新，只是内存中存在的前一代 Fiber，可能被 next update 的 current 复用



Reconciler 架构


React 整体可以拆成三层：

| 层级           | 名称   | 作用                                             |
| -------------- | ------ | ------------------------------------------------ |
| **Renderer**   | 渲染器 | 把更新操作应用到目标平台（如 DOM、React Native） |
| **Reconciler** | 协调器 | 对比前后虚拟树，计算需要更新的节点               |
| **Scheduler**  | 调度器 | 决定哪些更新优先执行（时间切片、任务调度）       |



![image-20251018135507704](https://gitee.com/K1217/typoralmage/raw/master/img/image-20251018135507704.png)

```
触发更新 (setState / render)
        ↓
Scheduler 调度优先级
        ↓
Reconciler 比较新旧 Fiber 树
        ↓
生成更新任务（EffectList）
        ↓
Renderer 执行 commit 阶段（更新真实 DOM）
```









协调器是 React 的**核心机制之一**，它是整个 React 渲染系统中最复杂、最关键的部分。 

虚拟 DOM 的调度和 diff 算法核心





核心模块则消费jsx编译后的结果，不是在element结构的基础上修改，还需要用一个结构包裹一层，用来区分、扩展的结构，介于element与ui之间的结构



#### FiberNode节点构造

​	因此，我们需要一个  介于element与真实dom之间、可以表达节点关系，更要符合扩展（数据存储单元与工作单元）的结构 ： FiberNode节点

```
// ------------------- Fiber 节点基本信息 -------------------
tag: WorkTag;         // Fiber 类型：FunctionComponent / ClassComponent / HostComponent / HostRoot 等
key: Key;             // 唯一标识，用于同级节点 diff 比较
type: any;            // 节点对应的元素类型：DOM 标签名或组件函数/类
stateNode: any;       // 真实世界对象：DOM 节点 / class 实例 / root 容器等
ref: Ref | null;      // ref 对象，用于绑定组件实例或 DOM 引用

// ------------------- Fiber 树结构 -------------------
return: FiberNode | null;  // 指向父 Fiber
child: FiberNode | null;   // 指向第一个子 Fiber
sibling: FiberNode | null; // 指向下一个兄弟 Fiber
index: number;             // 在父节点子节点列表中的索引位置

// ------------------- Props 和更新相关 -------------------
padingProps: Props;        // 本次更新要传给组件的 props（Pending Props）
memoizedProps: Props | null; // 上一次渲染生效的 props，用于 diff 对比
```



#### 工作方式

构造完之后，我们来实现 Reconciler 的工作方式



React 通过 Reconciler 递归读取 ReactElemen：

- **首次渲染（Mount）**：根据 JSX 生成全新的 FiberNode，形成初始 Fiber 树，所有节点都会被标记为 `Placement`。
- **更新阶段（Update）**：通过基于用Diff 算法比较旧的 Current 树和新的 React Element构建新 FiberNode（workInProgress） ），复用或新建节点，并标记变更（如插入、更新、删除）。
- **生成标记副作用（effectTag / flags）**：为需要 DOM 操作的节点添加标记（如 `Placement`、`Update`、`Deletion`）

> **双缓存机制**：这两棵树在每次更新时“交替使用”——新的成为 current，旧的被复用或丢弃
> **双缓冲**只在更新阶段存在：current ↔ workInProgress
>
> FiberNode.alternate 用来连接互相新旧节点， 是 diff 的结果
> `alternate` 是 Fiber **双缓冲、状态递进、effect 独立、节点复用与并发安全** 的核心支撑机制



JSX的消费顺序

**DFS 递归架构**

DFS深度优先遍历与BFS广度优先遍历

DFS深度优先遍历：

​	先遍历子节点再返回遍历兄弟节点

| 递归阶段             | React 内部函数        | 作用                                                         |
| -------------------- | --------------------- | ------------------------------------------------------------ |
| **递：beginWork**    | `beginWork(fiber)`    | 构建 Fiber 的子节点（child），决定下一个要处理的 Fiber。即“向下深入”。 |
| **归：completeWork** | `completeWork(fiber)` | 子节点都处理完后，执行当前 Fiber 的收尾（如生成 DOM、收集 effectList）。即“回溯返回”。 |



核心目标：**构建一棵 Fiber 树（即 workInProgress 树）**
 流程分为三层：

1. **入口层**：`renderRoot()`
2. **循环层**：`workLoop()`
3. **单元执行层**：`performUnitOfWork()` + `completeUnitOfWork()`







































#### 

#### 



#### 

#### 

#### props 与ref 的本质区别：

其实两个的生态位不一样，ref作为数据存储的，props作为属性工作的，一个是父组件使用时候传入的对应参数工作的，一个是真实dom传入使用这个树的

**props 的生态位：属性工作线**

- 来源：父组件传入 JSX 属性
- 用途：组件逻辑和渲染工作
- 生命周期：**render 阶段**读取
- 表现形式：Fiber 的 `pendingProps` / `memoizedProps`
- 作用对象：**组件内部函数 / class 渲染逻辑**



**ref 的生态位：引用/数据存储线**

- 来源：父组件传入 `ref`
- 用途：存储对子组件实例或 DOM 的指针，方便父组件操作
- 生命周期：**commit 阶段**绑定到真实对象
- 表现形式：Fiber 的 `ref` 字段，指向 `RefObject`
- 作用对象：**真实 DOM 或 class 实例**（stateNode）







#### alternate 属性可以直接使用浅拷贝代替吗

alternate 优势：

它是 **链式状态传递 + 独立副作用维护 + 历史复用** 的核心机制。

**1️⃣ 链式结构与状态递进**

- 每个 Fiber 通过 `alternate` 链接到上一轮对应节点，形成 **链式结构**。
- 保证每层状态独立、可追溯，并在上一轮状态基础上递进更新。
- 即使更新中断，也可以回退到 current 树，重新构建 workInProgress。
- 类似原型链和 Git 历史快照，实现安全的增量状态变更。

------

**2️⃣ 节点复用与 identity 保持**

- workInProgress 节点直接复用旧节点状态（hooks、memoizedProps、refs 等），保持 Fiber 节点对象 identity。
- 避免重复创建节点，提高性能，同时支持递进式更新整棵 Fiber 树。
- commit 后，旧 Fiber 作为历史树保留，下一轮更新可继续复用。

------

**3️⃣ 高效 diff 与 effect list 独立维护**

- Reconciliation 阶段通过 `current.alternate` 对比属性变化，**高效构建 effect list**。
- effect list 属于当前 workInProgress 树，独立于稳定的 current 树，避免污染。
- 浅拷贝无法保持节点 identity，也无法独立维护 effect list，因此无法替代。



如果是直接浅拷贝的话，不会独立每层的单独记录，会污染全局，更不会可以回档这种遇到中断或者错误的保障

**浅拷贝无法独立记录每层状态**

- 浅拷贝只是复制对象的表面属性，内部引用（如子节点、hooks、effect list）还是指向原对象。
- 这意味着每层 Fiber 的状态和副作用不是独立的，修改一层可能会影响其他层，**污染全局状态**。

**没有链式递进和历史快照**

- alternate 形成链式结构，每层 Fiber 可以访问上一轮状态，实现递进更新。
- 浅拷贝断开了这种链式引用，**无法回溯到上一轮状态**，也就无法安全中断或回退。

**无法保证错误恢复或中断安全**

- 在 Concurrent Mode 下，workInProgress 可能被中断。
- alternate 允许 React 随时回退到 current 树并重新构建 workInProgress。
- 浅拷贝没有历史链，遇到中断或错误只能重新创建整个结构，**不能像 alternate 一样安全恢复**。

















